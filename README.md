## Висновки за результатами тестування алгоритмів сортування

### Алгоритми:
- **Merge Sort** це класичний алгоритм злиття зі складністю `O(n log n)`
- **Insertion Sort** це простий алгоритм сортування зі складністю `O(n²)`
- **Timsort** це вбудований алгоритм у Python (`sorted()` / `.sort()`), який поєднує Merge Sort та Insertion Sort

### Результати (час у секундах):

| Розмір масиву | Merge Sort | Insertion Sort | Timsort (sorted) |
|---------------|------------|----------------|------------------|
| 1 000         | 0.00349    | 0.02943        | 0.00011          |
| 5 000         | 0.01230    | 0.63933        | 0.00062          |
| 10 000        | 0.02377    | 2.64341        | 0.00129          |
| 20 000        | 0.05200    | 9.78764        | 0.00269          |
| 40 000        | 0.11292    | 44.28287       | 0.00568          |

### Аналіз:
- **Timsort** стабільно найшвидший на всіх розмірах даних.
- **Insertion Sort** демонструє різке зростання часу при збільшенні обсягу даних, що відповідає теоретичній складності `O(n²)`.
- **Merge Sort** працює стабільно й ефективно, але все ж повільніше за Timsort.
- **Timsort** об'єднує переваги обох підходів:
  - Insertion Sort це швидкий на невеликих відсортованих підмасивах
  - Merge Sort - для злиття більших частин

### Висновок:
> Вбудований в Python алгоритм **Timsort** демонструє найвищу продуктивність завдяки комбінації insertion та merge-сортування.  
> Це робить його кращим вибором для практичного використання — тому програмісти використовують саме `sorted()` або `.sort()`, а не реалізують сортування вручну.
